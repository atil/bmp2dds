using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BmpToDds.Code
{
    /// <summary>
    /// Represents an RGB color and its de/serialization
    /// </summary>
    public class Pixel
    {
        public int R { get; }
        public int G { get; }
        public int B { get; }

        public Pixel(int r, int g, int b)
        {
            R = r;
            G = g;
            B = b;
        }

        public Pixel(short rgb565)
        {
            R = rgb565 & 0xf800; // First 5 bits
            G = rgb565 & 0x7e0; // Midd 6 bits
            B = rgb565 & 0x1f; // Last 5 bits

            // Extrapolate to 8 bits each
            // 5 bits == 32 values
            // 6 bits == 64 values
            // 8 bits == 256 values
            // http://stackoverflow.com/questions/2442576/how-does-one-convert-16-bit-rgb565-to-24-bit-rgb888
            R = (int) (R / 32f * 255);
            G = (int) (G / 64f * 255);
            B = (int) (B / 32f * 255);
        }

        public short ToRgb565()
        {
            var r = (R >> 3) << 11; // First 5 bits
            var g = (G >> 2) << 5; // Mid 6 bits
            var b = (B >> 3); // Last 5 bits

            return (short)(r | g | b); // 16 bits in total, which is a short
        }

        public byte[] ToRgb888()
        {
            return new[] { (byte)B, (byte)G, (byte)R }; // Notice BGR order
        }

        #region Operators
        // Probably half of them isn't used here
        public static Pixel operator +(Pixel a, Pixel b)
        {
            return new Pixel(a.R + b.R, a.G + b.G, a.B + b.B);
        }

        public static Pixel operator -(Pixel a, Pixel b)
        {
            return new Pixel(a.R - b.R, a.G - b.G, a.B - b.B);
        }

        public static Pixel operator *(Pixel a, int i)
        {
            return new Pixel(a.R * i, a.G * i, a.B * i);
        }

        public static Pixel operator /(Pixel a, int i)
        {
            return new Pixel(a.R / i, a.G / i, a.B / i);
        }

        public static bool operator ==(Pixel a, Pixel b)
        {
            if (ReferenceEquals(a, null))
            {
                return ReferenceEquals(b, null);
            }
            return a.Equals(b);
        }

        public static bool operator !=(Pixel a, Pixel b)
        {
            return !(a == b);
        }
        #endregion

        #region Equality etc.
        // To make R# happy -- autogenerated
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != this.GetType()) return false;
            return Equals((Pixel)obj);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                var hashCode = R;
                hashCode = (hashCode * 397) ^ G;
                hashCode = (hashCode * 397) ^ B;
                return hashCode;
            }
        }
        #endregion
    }
}
