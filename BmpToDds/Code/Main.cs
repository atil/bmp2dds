using System;
using System.Collections;
using System.IO;
using System.Linq;

namespace BmpToDds.Code
{
    public class Pixel
    {
        public int R { get; }
        public int G { get; }
        public int B { get; }
        public int Sum { get; }

        public Pixel(int r, int g, int b)
        {
            R = r;
            G = g;
            B = b;
            Sum = r + g + b;
        }

        public short ToRgb565()
        {
            var r = (R >> 3) << 11;
            var g = (G >> 2) << 5;
            var b = (B >> 3);
            return (short)(r | g | b);
        }

        #region Operators
        public static Pixel operator +(Pixel a, Pixel b)
        {
            return new Pixel(a.R + b.R, a.G + b.G, a.B + b.B);
        }

        public static Pixel operator -(Pixel a, Pixel b)
        {
            return new Pixel(a.R - b.R, a.G - b.G, a.B - b.B);
        }

        public static Pixel operator *(Pixel a, int i)
        {
            return new Pixel(a.R * i, a.G * i, a.B * i);
        }

        public static Pixel operator /(Pixel a, int i)
        {
            return new Pixel(a.R / i, a.G / i, a.B / i);
        }

        public static bool operator ==(Pixel a, Pixel b)
        {
            if (ReferenceEquals(a, null))
            {
                return ReferenceEquals(b, null);
            }
            return a.Equals(b);
        }

        public static bool operator !=(Pixel a, Pixel b)
        {
            return !(a == b);
        }
        #endregion

        #region Equality etc.
        // To make R# happy -- autogenerated
        //protected bool Equals(Pixel other)
        //{
        //    return R == other.R && G == other.G && B == other.B;
        //}

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != this.GetType()) return false;
            return Equals((Pixel) obj);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                var hashCode = R;
                hashCode = (hashCode * 397) ^ G;
                hashCode = (hashCode * 397) ^ B;
                return hashCode;
            }
        }
        #endregion
    }

    public static class Program
    {
        static void Main(string[] args)
        {
            const string bmpFileName = "../Assets/example.bmp";
            const string ddsFileName = "../Assets/dump2.dds";

            var bmpBytes = File.ReadAllBytes(bmpFileName);
            using (var stream = new MemoryStream(bmpBytes))
            {
                // Read bmp properties
                stream.Seek(14, SeekOrigin.Begin); // Begins at 14
                var headerSize = stream.ReadInt();
                var bmpWidth = stream.ReadInt();
                var bmpHeight = stream.ReadInt();

                // Discard errorneous input
                // TODO: Discard also non-24bpp images
                if ((bmpWidth % 4 != 0) || (bmpHeight % 4 != 0))
                {
                    stream.Dispose();
                    Console.WriteLine("Image dimensions are not a multiply of 4");
                    return;
                }

                // Skip bmp header
                stream.Seek(54, SeekOrigin.Begin);

                // Read color data from bmp
                var pixels = new Pixel[bmpWidth, bmpHeight];

                // BMP has its origin at lower-left
                // To make it top-left, we invert .... *drumroll*
                // WIDTH!
                // Don't know why, but after trial and error this produced a meaningful thing
                // It seems like BMP keeps things column-wise
                var w = bmpWidth - 1;
                var h = 0;
                for (var i = 54; i < bmpBytes.Length; i += 3)
                {
                    var b = stream.ReadByte();
                    var g = stream.ReadByte();
                    var r = stream.ReadByte();
                    var p = new Pixel(r, g, b);

                    pixels[w, h] = p;

                    h++; // Walk on height-first
                    if (h == bmpHeight)
                    {
                        h = 0;
                        w--;
                    }
                }

                // Write DDS
                using (var fs = new FileStream(ddsFileName, FileMode.OpenOrCreate))
                {
                    fs.WriteByte((byte)'D');
                    fs.WriteByte((byte)'D');
                    fs.WriteByte((byte)'S');
                    fs.WriteByte((byte)' ');

                    fs.WriteInt(124); // Header size
                    fs.WriteInt(0x0000100f); // Flags indicating what info is in the header (well...)
                    fs.WriteInt(bmpWidth); // Width
                    fs.WriteInt(bmpHeight); // Height
                    fs.WriteInt(((bmpWidth + 3) / 4) * 8); // Pitch or Linear size (yup that's the one)
                    fs.WriteInt(0); // Depth
                    fs.WriteInt(0); // Mipmap count
                    for (var i = 0; i < 11; i++) // Reserved
                    {
                        fs.WriteInt(0);
                    }

                    // Pixelformat
                    fs.WriteInt(0x00000020); // Size
                    fs.WriteInt(0x00000040); // Flags about who's in here
                    fs.WriteInt(0); // FourCC (don't know what this is)
                    fs.WriteInt(0x00000010); // RGB bit count
                    fs.WriteInt(0x0000f800); // R bitmask
                    fs.WriteInt(0x000007e0); // G bitmask
                    fs.WriteInt(0x0000001f); // B bitmask
                    fs.WriteInt(0); // Alpha bitmask
                    fs.WriteInt(0x00001000); // Caps
                    fs.WriteInt(0); // Caps2
                    fs.WriteInt(0); // Caps3
                    fs.WriteInt(0); // Caps4
                    fs.WriteInt(0); // Reserved

                    foreach (var pixel in pixels)
                    {
                        // Can't believe that all 4x4 texel business is a lie...
                        var pixelBytes = BitConverter.GetBytes(pixel.ToRgb565());
                        fs.Write(pixelBytes, 0, pixelBytes.Length);
                    }

                    // TODO: Mipmaps here? 
                    // Lol nope
                }

            }

        }
    }
}
