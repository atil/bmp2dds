using System;
using System.Collections;
using System.IO;
using System.Linq;

namespace BmpToDds.Code
{
    public class Pixel
    {
        public int R { get; }
        public int G { get; }
        public int B { get; }
        public int Sum { get; }

        public Pixel(int r, int g, int b)
        {
            R = r;
            G = g;
            B = b;
            Sum = r + g + b;
        }

        public int ToRgb565()
        {
            var r = (R >> 3) << 11;
            var g = (G >> 2) << 5;
            var b = (B >> 3);
            return r | g | b;
        }

        #region Operators
        public static Pixel operator +(Pixel a, Pixel b)
        {
            return new Pixel(a.R + b.R, a.G + b.G, a.B + b.B);
        }

        public static Pixel operator -(Pixel a, Pixel b)
        {
            return new Pixel(a.R - b.R, a.G - b.G, a.B - b.B);
        }

        public static Pixel operator *(Pixel a, int i)
        {
            return new Pixel(a.R * i, a.G * i, a.B * i);
        }

        public static Pixel operator /(Pixel a, int i)
        {
            return new Pixel(a.R / i, a.G / i, a.B / i);
        }

        public static bool operator ==(Pixel a, Pixel b)
        {
            if (ReferenceEquals(a, null))
            {
                return ReferenceEquals(b, null);
            }
            return a.Equals(b);
        }

        public static bool operator !=(Pixel a, Pixel b)
        {
            return !(a == b);
        }
        #endregion

        #region Equality etc.
        // To make R# happy -- autogenerated
        //protected bool Equals(Pixel other)
        //{
        //    return R == other.R && G == other.G && B == other.B;
        //}

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != this.GetType()) return false;
            return Equals((Pixel) obj);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                var hashCode = R;
                hashCode = (hashCode * 397) ^ G;
                hashCode = (hashCode * 397) ^ B;
                return hashCode;
            }
        }
        #endregion
    }

    public class Texel
    {
        public readonly Pixel[] Pixels; // Exactly 16
        private readonly int _indexBits;
        private readonly int _rgb565Bits;

        public Texel(Pixel[] pxls)
        {
            Pixels = pxls;

            // Find 4 colors of palette
            var max = Pixels.Aggregate((next, curr) => next.Sum < curr.Sum ? curr : next);
            var min = Pixels.Aggregate((next, curr) => next.Sum > curr.Sum ? curr : next);
            var midLower = min + (max - min) / 3;
            var midHigher = min + (max - min) * 2 / 3;

            var palette = new Pixel[]
            {
                min, midLower, midHigher, max
            };

            // Set anchor colors
            _rgb565Bits = (min.ToRgb565() << 16) | max.ToRgb565();

            // Find palette indices for each pixel
            var indexBitArray = new BitArray(32);
            for (var i = 0; i < Pixels.Length; i++)
            {
                var minDist = int.MaxValue;
                var closestOnPalette = 0; // Index on palette

                for (var j = 0; j < palette.Length; j++)
                {
                    var dist = Math.Abs(palette[j].Sum - Pixels[i].Sum);
                    if (dist < minDist)
                    {
                        minDist = dist;
                        closestOnPalette = j;
                    }
                }

                // A whole lot smarter thing could be done here
                var bit0 = false;
                var bit1 = false;
                switch (closestOnPalette)
                {
                    case 0:
                        bit0 = false;
                        bit1 = false;
                        break;
                    case 1:
                        bit0 = false;
                        bit1 = true;
                        break;
                    case 2:
                        bit0 = true;
                        bit1 = false;
                        break;
                    case 3:
                        bit0 = true;
                        bit1 = true;
                        break;
                }

                indexBitArray[2 * i] = bit0;
                indexBitArray[2 * i + 1] = bit1;
            }

            _indexBits = indexBitArray.ToInt();
        }

        public byte[] GetBytes()
        {
            // Concat bytes
            var anchorBytes = BitConverter.GetBytes(_rgb565Bits);
            var indexBytes = BitConverter.GetBytes(_indexBits);
            return anchorBytes.Concat(indexBytes).ToArray();
        }
    }

    public static class Program
    {
        static void Main(string[] args)
        {
            const string bmpFileName = "../Assets/example.bmp";

            var bmpBytes = File.ReadAllBytes(bmpFileName);
            using (var stream = new MemoryStream(bmpBytes))
            {
                // Read bmp properties
                stream.Seek(14, SeekOrigin.Begin);
                var headerSize = stream.ReadInt();
                var imageWidth = stream.ReadInt();
                var imageHeight = stream.ReadInt();

                // Discard errorneous input
                if ((imageWidth % 4 != 0) || (imageHeight % 4 != 0))
                {
                    stream.Dispose();
                    Console.WriteLine("Image dimensions are not a multiply of 4");
                    return;
                }

                // Skip bmp header
                stream.Seek(54, SeekOrigin.Begin);

                // Read color data from bmp
                var pixels = new Pixel[imageWidth, imageHeight];
                var w = 0;
                var h = 0;
                var ii = 0;
                for (var i = 54; i < bmpBytes.Length; i += 3)
                {
                    var b = stream.ReadByte();
                    var g = stream.ReadByte();
                    var r = stream.ReadByte();
                    var p = new Pixel(r, g, b);

                    pixels[w, h] = p;

                    w++;
                    if (w == imageWidth)
                    {
                        w = 0;
                        h++;
                    }
                    ii = i;
                }

                var c = 3;

                for (int i = 0; i < imageWidth; i++)
                {
                    for (int j = 0; j < imageHeight; j++)
                    {
                        if (pixels[i, j] == null)
                        {
                            var a = 3;
                        }
                    }
                }
               
                // Construct texels
                var texels = new Texel[imageWidth / 4, imageHeight / 4];
                for (var j = 0; j < imageHeight; j += 4)
                {
                    for (var i = 0; i < imageWidth; i += 4)
                    {
                        // 4x4 pixels => 1 texel
                        texels[i / 4, j / 4] = new Texel(new Pixel[]
                        {
                            pixels[i, j], pixels[i + 1, j], pixels[i + 2, j], pixels[i + 3, j],
                            pixels[i, j + 1], pixels[i + 1, j + 1], pixels[i + 2, j + 1], pixels[i + 3, j + 1],
                            pixels[i, j + 2], pixels[i + 1, j + 2], pixels[i + 2, j + 2], pixels[i + 3, j + 2],
                            pixels[i, j + 3], pixels[i + 1, j + 3], pixels[i + 2, j + 3], pixels[i + 3, j + 3],
                        });
                    }
                }

                using (var fs = new FileStream("../Assets/dump2.dds", FileMode.OpenOrCreate))
                {
                    fs.WriteByte((byte)'D');
                    fs.WriteByte((byte)'D');
                    fs.WriteByte((byte)'S');
                    fs.WriteByte((byte)' ');

                    fs.WriteInt(124); // Header size
                    fs.WriteInt(0x000010f0); // Flags indicating what info is in the header (well...)
                    fs.WriteInt(imageWidth); // Width
                    fs.WriteInt(imageHeight); // Height
                    fs.WriteInt(8); // Pitch or Linear size (yup that's the one)
                    fs.WriteInt(0); // Depth
                    fs.WriteInt(0); // Mipmap count
                    for (int i = 0; i < 11; i++) // Reserved
                    {
                        fs.WriteInt(0);
                    }

                    // Pixelformat
                    fs.WriteInt(0x00000020); // Size
                    fs.WriteInt(0x00000040); // Flags about who's in here
                    fs.WriteInt(0); // FourCC (don't know what this is)
                    fs.WriteInt(0x00000010); // RGB bit count
                    fs.WriteInt(0x0000f800); // R bitmask
                    fs.WriteInt(0x000007e0); // G bitmask
                    fs.WriteInt(0x0000001f); // B bitmask
                    fs.WriteInt(0); // A bitmask
                    fs.WriteInt(0x00001000); // Caps
                    fs.WriteInt(0); // Caps2
                    fs.WriteInt(0); // Caps3
                    fs.WriteInt(0); // Caps4
                    fs.WriteInt(0); // Reserved

                    foreach (var texel in texels)
                    {
                        var b = texel.GetBytes();
                        fs.Write(b, 0, b.Length);
                    }
                 
                    // Mipmaps here?   
                }

                //Console.WriteLine($"pixels {w} {h}");
                //Console.ReadLine();
            }


            // We should have our image converted at this point
            // Begin writing dds
            //using (var fs = new FileStream("../Assets/out.dds", FileMode.OpenOrCreate))
            //{
            //    // Magic string
            //    fs.WriteByte((byte)'D');
            //    fs.WriteByte((byte)'D');
            //    fs.WriteByte((byte)'S');
            //    fs.WriteByte((byte)' ');

            //    fs.WriteInt(124); // Header size
            //}

        }
    }
}
