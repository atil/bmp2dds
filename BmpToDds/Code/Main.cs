using System;
using System.Collections;
using System.IO;
using System.Linq;

namespace BmpToDds.Code
{
    public class Pixel
    {
        public int R { get; }
        public int G { get; }
        public int B { get; }
        public int Sum { get; }

        public Pixel(int r, int g, int b)
        {
            R = r;
            G = g;
            B = b;
            Sum = r + g + b;
        }

        public Pixel(short rgb565)
        {
            R = rgb565 & 0xf800; // First 5 bits
            G = rgb565 & 0x7e0; // Midd 6 bits
            B = rgb565 & 0x1f; // Last 5 bits
        }

        public short ToRgb565()
        {
            var r = (R >> 3) << 11; // First 5 bits
            var g = (G >> 2) << 5; // Mid 6 bits
            var b = (B >> 3); // Last 5 bits
            return (short)(r | g | b); // 16 bits in total, which is a short
        }

        #region Operators
        public static Pixel operator +(Pixel a, Pixel b)
        {
            return new Pixel(a.R + b.R, a.G + b.G, a.B + b.B);
        }

        public static Pixel operator -(Pixel a, Pixel b)
        {
            return new Pixel(a.R - b.R, a.G - b.G, a.B - b.B);
        }

        public static Pixel operator *(Pixel a, int i)
        {
            return new Pixel(a.R * i, a.G * i, a.B * i);
        }

        public static Pixel operator /(Pixel a, int i)
        {
            return new Pixel(a.R / i, a.G / i, a.B / i);
        }

        public static bool operator ==(Pixel a, Pixel b)
        {
            if (ReferenceEquals(a, null))
            {
                return ReferenceEquals(b, null);
            }
            return a.Equals(b);
        }

        public static bool operator !=(Pixel a, Pixel b)
        {
            return !(a == b);
        }
        #endregion

        #region Equality etc.
        // To make R# happy -- autogenerated
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != this.GetType()) return false;
            return Equals((Pixel) obj);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                var hashCode = R;
                hashCode = (hashCode * 397) ^ G;
                hashCode = (hashCode * 397) ^ B;
                return hashCode;
            }
        }
        #endregion
    }

    public static class Program
    {
        private const string Bmp2DdsOp = "-bmp2dds";
        private const string Dds2BmpOp = "-dds2bmp";

        static void Main(string[] args)
        {
            // To speed up development
            if (args.Length == 0)
            {
                const string bmpFileName = "../Assets/example.bmp";
                const string ddsFileName = "../Assets/dump2.dds";
                //Bmp2Dds(bmpFileName, ddsFileName);
                Dds2Bmp(ddsFileName, bmpFileName);
                return;
            }

            // Read cmdline args and make sure they are the things we want
            if (args.Length != 3)
            {
                Console.WriteLine("Usage: <option> <input file> <output file>");
                Console.ReadLine();
                return;
            }
            var option = args[0];
            if (option != Bmp2DdsOp || option != Dds2BmpOp)
            {
                Console.WriteLine("Invalid option. Use either -bmp2dds or -dds2bmp");
                Console.ReadLine();
                return;
            }

            var inputFileName = args[1];
            var inputFileInfo = new FileInfo(inputFileName);
            
            var outputFileName = args[2];
            var outputFileInfo = new FileInfo(outputFileName);

            if (option == Bmp2DdsOp)
            {
                Utility.Assert(inputFileInfo.Extension == "bmp", "Input must be bmp file");
                Utility.Assert(outputFileInfo.Extension == "dds", "Output must be dds file");
                Bmp2Dds(inputFileName, outputFileName);
            }
            else if (option == Dds2BmpOp)
            {
                Dds2Bmp(inputFileName, outputFileName);
            }
        }

        static void Bmp2Dds(string bmpFileName, string ddsFileName)
        {
            var bmpBytes = File.ReadAllBytes(bmpFileName);
            using (var stream = new MemoryStream(bmpBytes))
            {
                // Read bmp properties
                stream.Seek(14, SeekOrigin.Begin); // Begins at 14
                var headerSize = stream.ReadInt();
                var bmpWidth = stream.ReadInt(); // TODO: Is this short?
                var bmpHeight = stream.ReadInt();
                var numOfColorPlanes = stream.ReadShort();
                var colorDepth = stream.ReadShort();

                // Discard errorneous input
                if ((bmpWidth % 4 != 0) || (bmpHeight % 4 != 0))
                {
                    stream.Dispose();
                    Console.WriteLine("Image dimensions are not a multiply of 4");
                    return;
                }

                // Check 24bpp
                if (colorDepth != 24)
                {
                    stream.Dispose();
                    Console.WriteLine("BMP color depth must be 24");
                    return;
                }

                // Skip bmp header
                stream.Seek(54, SeekOrigin.Begin);

                // Read color data from bmp
                var pixels = new Pixel[bmpWidth, bmpHeight];

                // BMP has its origin at lower-left
                // To make it top-left, we invert .... *drumroll*
                // WIDTH!
                // Don't know why, but after trial and error this produced a meaningful thing
                // It seems like BMP keeps things column-wise
                var w = bmpWidth - 1;
                var h = 0;
                for (var i = 54; i < bmpBytes.Length; i += 3)
                {
                    var b = stream.ReadByte();
                    var g = stream.ReadByte();
                    var r = stream.ReadByte();
                    var p = new Pixel(r, g, b);

                    pixels[w, h] = p;

                    h++; // Walk on height-first
                    if (h == bmpHeight)
                    {
                        h = 0;
                        w--;
                    }
                }

                // Write DDS
                using (var fs = new FileStream(ddsFileName, FileMode.OpenOrCreate))
                {
                    fs.WriteByte((byte)'D');
                    fs.WriteByte((byte)'D');
                    fs.WriteByte((byte)'S');
                    fs.WriteByte((byte)' ');

                    fs.WriteInt(124); // Header size
                    fs.WriteInt(0x0000100f); // Flags indicating what info is in the header (well...)
                    fs.WriteInt(bmpWidth); // Width
                    fs.WriteInt(bmpHeight); // Height
                    fs.WriteInt(((bmpWidth + 3) / 4) * 8); // Pitch or Linear size (yup that's the one)
                    fs.WriteInt(0); // Depth
                    fs.WriteInt(0); // Mipmap count
                    for (var i = 0; i < 11; i++) // Reserved
                    {
                        fs.WriteInt(0);
                    }

                    // Pixelformat
                    fs.WriteInt(0x00000020); // Size
                    fs.WriteInt(0x00000040); // Flags about who's in here
                    fs.WriteInt(0); // FourCC (don't know what this is)
                    fs.WriteInt(0x00000010); // RGB bit count
                    fs.WriteInt(0x0000f800); // R bitmask
                    fs.WriteInt(0x000007e0); // G bitmask
                    fs.WriteInt(0x0000001f); // B bitmask
                    fs.WriteInt(0); // Alpha bitmask
                    fs.WriteInt(0x00001000); // Caps
                    fs.WriteInt(0); // Caps2
                    fs.WriteInt(0); // Caps3
                    fs.WriteInt(0); // Caps4
                    fs.WriteInt(0); // Reserved

                    foreach (var pixel in pixels)
                    {
                        // Can't believe that all 4x4 texel business is a lie...
                        var pixelBytes = BitConverter.GetBytes(pixel.ToRgb565());
                        fs.Write(pixelBytes, 0, pixelBytes.Length);
                    }

                    // TODO: Mipmaps here? 
                    // Lol nope
                }

            }
        }

        static void Dds2Bmp(string ddsFileName, string bmpFileName)
        {
            var ddsBytes = File.ReadAllBytes(ddsFileName);
            using (var stream = new MemoryStream(ddsBytes))
            {
                // We're only interested in width and height
                stream.Seek(12, SeekOrigin.Begin);
                var imageWidth = stream.ReadInt();
                var imageHeight = stream.ReadInt();

                stream.Seek(128, SeekOrigin.Begin); // Move to actual image data
                var pixels = new Pixel[imageWidth, imageHeight];
                var w = 0;
                var h = 0;
                while (stream.CanRead) // Read bytes till the end of file
                {
                    // Two bytes == 1 color (R5G5B5)
                    var byte0 = stream.ReadByte();
                    var byte1 = stream.ReadByte();

                    var s = (short)(byte1 << 8 | byte0); 
                    pixels[w, h] = new Pixel(s);

                    w++;
                    if (w == imageWidth)
                    {
                        w = 0;
                        h++;
                    }
                }

                // TODO: Write header here

            }
        }
    }
}
