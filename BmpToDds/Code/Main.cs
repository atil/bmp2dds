using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BmpToDds
{
    public class Pixel
    {
        public int R { get; }
        public int G { get; }
        public int B { get; }
        public int Sum { get; }

        public Pixel(int r, int g, int b)
        {
            R = r;
            G = g;
            B = b;
            Sum = r + g + b;
        }

        public static Pixel operator +(Pixel a, Pixel b)
        {
            return new Pixel(a.R + b.R, a.G + b.G, a.B + b.B);
        }

        public static Pixel operator -(Pixel a, Pixel b)
        {
            return new Pixel(a.R - b.R, a.G - b.G, a.B - b.B);
        }

        public static Pixel operator *(Pixel a, int i)
        {
            return new Pixel(a.R * i, a.G * i, a.B * i);
        }

        public static Pixel operator /(Pixel a, int i)
        {
            return new Pixel(a.R / i, a.G / i, a.B / i);
        }

        public static bool operator ==(Pixel a, Pixel b)
        {
            return a != null && b != null &&
                a.R == b.R && a.G == b.G && a.B == b.B;
        }

        public static bool operator !=(Pixel a, Pixel b)
        {
            return !(a == b);
        }

        #region Equality etc.
        // To make R# happy -- autogenerated
        protected bool Equals(Pixel other)
        {
            return R == other.R && G == other.G && B == other.B;
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != this.GetType()) return false;
            return Equals((Pixel) obj);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                var hashCode = R;
                hashCode = (hashCode * 397) ^ G;
                hashCode = (hashCode * 397) ^ B;
                return hashCode;
            }
        }
        #endregion
    }

    public class Texel
    {
        public readonly Pixel[] Pixels;
        private readonly Pixel[] _palette;
        private readonly BitArray _indexBits;

        public Texel(Pixel[] pxls)
        {
            Pixels = pxls;
            
            // Find 4 colors of palette
            var max = Pixels.Aggregate((next, curr) => next.Sum < curr.Sum ? curr : next);
            var min = Pixels.Aggregate((next, curr) => next.Sum > curr.Sum ? curr : next);
            var midLower = min + (max - min) / 3;
            var midHigher = min + (max - min) * 2 / 3;
            _palette = new Pixel[]
            {
                min, midLower, midHigher, max
            };

            // Find palette indices for each pixel
            _indexBits = new BitArray(32);
            for (var i = 0; i < Pixels.Length; i++)
            {
                var minDist = int.MaxValue;
                var closestOnPalette = 0; // Index on palette

                for (var j = 0; j < _palette.Length; j++)
                {
                    var dist = Math.Abs(_palette[j].Sum - Pixels[i].Sum);
                    if (dist < minDist)
                    {
                        minDist = dist;
                        closestOnPalette = j;
                    }
                }

                // A whole lot smarter thing could be done here
                var bit0 = false;
                var bit1 = false;
                switch (closestOnPalette)
                {
                    case 0:
                        bit0 = false;
                        bit1 = false;
                        break;
                    case 1:
                        bit0 = false;
                        bit1 = true;
                        break;
                    case 2:
                        bit0 = true;
                        bit1 = false;
                        break;
                    case 3:
                        bit0 = true;
                        bit1 = true;
                        break;
                }

                _indexBits[i] = bit0;
                _indexBits[i + 1] = bit1;
            }
        }

        public byte[] GetBytes()
        {
            return new byte[0];
        }
    }

    public static class Program
    {
        static int ReadIntFrom(Stream s)
        {
            var bytes = new byte[4];
            s.Read(bytes, 0, 4);
            return BitConverter.ToInt32(bytes, 0);
        }

        static void Main(string[] args)
        {
            const string bmpFileName = "../Assets/example.bmp";

            var bmpBytes = File.ReadAllBytes(bmpFileName);
            using (var stream = new MemoryStream(bmpBytes))
            {
                // Read bmp properties
                stream.Seek(14, SeekOrigin.Begin);
                var headerSize = ReadIntFrom(stream);
                var imageWidth = ReadIntFrom(stream);
                var imageHeight = ReadIntFrom(stream);

                // Discard errorneous input
                if ((imageWidth % 4 != 0) || (imageHeight % 4 != 0))
                {
                    stream.Dispose();
                    Console.WriteLine("Image dimensions are not a multiply of 4");
                    return;
                }

                // Skip bmp header
                stream.Seek(54, SeekOrigin.Begin);

                // Read color data from bmp
                var pixels = new Pixel[imageWidth, imageHeight];
                var w = 0;
                var h = 0;
                for (var i = 54; i < bmpBytes.Length; i += 3)
                {
                    var b = stream.ReadByte();
                    var g = stream.ReadByte();
                    var r = stream.ReadByte();
                    var p = new Pixel(r, g, b);

                    pixels[w, h] = p;

                    w++;
                    if (w == imageWidth)
                    {
                        w = 0;
                        h++;
                    }
                }

                // Construct texels
                var texels = new Texel[imageWidth / 4, imageHeight / 4];
                for (var j = 0; j < imageHeight; j += 4)
                {
                    for (var i = 0; i < imageWidth; i += 4)
                    {
                        // 4x4 pixels => 1 texel
                        texels[i / 4, j / 4] = new Texel(new Pixel[]
                        {
                            pixels[i, j], pixels[i + 1, j], pixels[i + 2, j], pixels[i + 3, j],
                            pixels[i, j + 1], pixels[i + 1, j + 1], pixels[i + 2, j + 1], pixels[i + 3, j + 1],
                            pixels[i, j + 2], pixels[i + 1, j + 2], pixels[i + 2, j + 2], pixels[i + 3, j + 2],
                            pixels[i, j + 3], pixels[i + 1, j + 3], pixels[i + 2, j + 3], pixels[i + 3, j + 3],
                        });
                    }
                }

                Console.WriteLine($"pixels {w} {h}");
                Console.ReadLine();
            }

        }
    }
}
